Shaders:
    1) RGB only
    2) RGBA, only full transparency
    3) RGBA, with blending

TODO:
FIX static sprites added later (stairs object) -> sometimes some sprites get "deleted" (?)

level generation
  !!! Remove test-button for level loading
  more settings (each floor different)
  enemy spawns in room definition
  multiple end-rooms (+ start rooms?)
  special rooms + limits? -> otherwise spawn specials in any room
  ? prevent generation instead of blocking later -> at least has to connect to existing rooms
  ? weighted room randomness
  Replace room::tile-type with tiles::tile-type

VFX
  visual effects (flashes on hit) -> add color tint to shader (implement like model-mats)
      -> second buffer for colors (or maybe interleaved in one?)
      -> slot IDs have to match up, but model mats don't need updating when color changes
      -> how to handle updates? -> static/dynamic position != color -> all colors dynamic? or selective updates directly to buffer?
  partial transparency
  light?

main gameplay
  upgrades
  enemy behaviors
  ladder(?) to next floor
  main menu
  fog-of-war?
  minimap?
  saving?
  audio(?)
  modular attacks(?)

collisions with mask (only certain tags)
remove *game-object-sprites*

Optimisations (performance):
Rendering
  partial updates for static render objects
  keep c-pointer (or directly edit buffer)
  gtk4
Collisions
  circle-aabb collision early return
  smarter collsions (space partitioning (sort and sweep: https://www.toptal.com/game/video-game-physics-part-ii-collision-detection-for-solid-objects) (+ broad phase?))
  separate x and y collision checks (currently both done twice)
  replace distance with square of distance
use with-vec?

Optimisations (usability):
? split texture into renderer + texture
all tags in one namespace?
behaviors in separate system?

Bugs:
should collision resolution result in countinuous collision?
      in general: (consistency) should distance=0 result in collision
replace constants with defvar/defparameter

==========UNUSED CODE==========
(let ((delta-time (/ 1 240))
          (start-time (local-time:now)))
      (loop while (> (gtk-main-level) 0) do
              ; TODO: sync with render thread

              ;(g-signal-emit area "render")
              (let ((move-dist (* 2 delta-time)))
                (when (get-key-hold "w")
                      (setf (sprite-position test-sprite) (3d-vectors:v+ (sprite-position test-sprite) (3d-vectors:vec 0 move-dist))))
                (when (get-key-hold "a")
                      (setf (sprite-position test-sprite) (3d-vectors:v+ (sprite-position test-sprite) (3d-vectors:vec (- move-dist) 0))))
                (when (get-key-hold "s")
                      (setf (sprite-position test-sprite) (3d-vectors:v+ (sprite-position test-sprite) (3d-vectors:vec 0 (- move-dist)))))
                (when (get-key-hold "d")
                      (setf (sprite-position test-sprite) (3d-vectors:v+ (sprite-position test-sprite) (3d-vectors:vec move-dist 0))))
            
                ;(when *keys-pressed*
                ;      (format t "Pressed: ~a~%" *keys-pressed*))
                (setf *keys-pressed* NIL)

                ; REDO TIME MEASUREMENT
                (let* ((end-time (local-time:now))
                       (wait-time (- delta-time (local-time:timestamp-difference end-time start-time))))
                  (format t "Waiting for: ~a~%" wait-time)
                  (when (> wait-time 0)
                      (sleep wait-time)))
                (setf start-time (local-time:now)))))

;; Behaves like a vector (allows push, resizing, etc.) but uses a gl-array as the data storage
(defclass gl-array-vector ()
    ((gl-array :initform NIL
               :reader gl-array-vector-gl-array)
     (size :initform 0
           :reader gl-array-vector-size)
     (capacity :initform 0
               :reader gl-array-vector-capacity)))

(defun make-gl-array-vector (element-type element-count)
  (let ((obj (make-instance 'gl-array-vector))) 
    (with-slots (gl-array size capacity) obj
      (setf gl-array (gl:alloc-gl-array element-type element-count))
      (setf size 0)
      (setf capacity element-count))
    obj))

(defmethod gl-array-vector-free-gl-array ((obj gl-array-vector))
  (with-slots (gl-array size capacity) obj
    (when gl-array
          (gl:free-gl-array gl-array))
    (setf size 0)
    (setf capacity 0)))

(defmethod gl-array-vector-clear ((obj gl-array-vector))
  (with-slots (size) obj
    (setf size 0)))

;; re-allocs array and copys over elements
;; only ever increases capacity
(defmethod gl-array-vector-reserve ((obj gl-array-vector) element-count)
  (with-slots (gl-array size capacity) obj
    (when (> element-count capacity)
          (setf capacity element-count)
          (let ((new-array (gl:alloc-gl-array (gl::gl-array-type gl-array) element-count)))
            (dotimes (i size)
              (setf (gl:glaref new-array i) (gl:glaref gl-array i)))
            (gl:free-gl-array gl-array)
            (setf gl-array new-array)))))

;; pushes multiple values (from a vector) at the same time
;; if reallocation is necessary, doubles allocated size
(defmethod gl-array-vector-push-vector ((obj gl-array-vector) value-vec)
  (with-slots (gl-array size capacity) obj
    (when (> (+ size (length value-vec)) capacity)
          (gl-array-vector-reserve obj (max (* 2 capacity) (+ size (length value-vec)))))
    (dotimes (i (length value-vec))
      (setf (gl:glaref gl-array size) (aref value-vec i))
      (incf size))))

(defmethod gl-array-vector-print ((obj gl-array-vector))
  (with-slots (gl-array size capacity) obj
    (format t "Size: ~a~%Capacity: ~a~%" size capacity)
    (dotimes (i size)
      (format t "~a " (gl:glaref gl-array i)))
    (format t "~%")))

;; Behaves like a vector (allows push, resizing, etc.) but uses a gl-buffer as the data storage
(defclass gl-buffer-vector ()
    ((gl-buffer :initform NIL
               :reader gl-buffer-vector-gl-buffer)
     (size :initform 0
           :reader gl-buffer-vector-size)
     (capacity :initform 0
               :reader gl-buffer-vector-capacity)))

(defun make-gl-buffer-vector ()
  (let ((obj (make-instance 'gl-buffer-vector))) 
    (with-slots (gl-buffer size capacity) obj
      (setf gl-buffer (gl:gen-buffer))
      (gl:bind-buffer :array-buffer gl-buffer)
      (let ((gl-array (gl:alloc-gl-array :float 1)))
        (gl:buffer-data :array-buffer :dynamic-draw gl-array))
      (gl:bind-buffer :array-buffer 0)
      (setf size 0)
      (setf capacity 0))
    obj))

(defmethod gl-buffer-vector-delete-buffer ((obj gl-buffer-vector))
  (with-slots (gl-buffer size capacity) obj
    (when gl-buffer
          (gl:delete-buffers (list gl-buffer)))
    (setf size 0)
    (setf capacity 0)))

(defmethod gl-buffer-vector-clear ((obj gl-buffer-vector))
  (with-slots (size) obj
    (setf size 0)))

;; re-allocs array and copys over elements
;; only ever increases capacity
(defmethod gl-buffer-vector-reserve ((obj gl-buffer-vector) element-count)
  (with-slots (gl-buffer size capacity) obj
    (when (> element-count capacity)
          (setf capacity element-count)

          (let ((new-buffer (gl:gen-buffer))
                (tmp-array (gl:alloc-gl-array :float element-count)))
            (gl:bind-buffer :copy-read-buffer gl-buffer)
            (gl:bind-buffer :copy-write-buffer new-buffer)
            
            (gl:buffer-data :copy-write-buffer :dynamic-draw tmp-array)
            (%gl:copy-buffer-sub-data :copy-read-buffer :copy-write-buffer 0 0 (* size (cffi:foreign-type-size :float)))
            
            (gl:free-gl-array tmp-array)
            (gl:delete-buffers (list gl-buffer))
            (setf gl-buffer new-buffer)
            (gl:bind-buffer :copy-read-buffer 0)
            (gl:bind-buffer :copy-write-buffer 0)))))

;; pushes multiple values (from a vector) at the same time
;; if reallocation is necessary, doubles allocated size
(defmethod gl-buffer-vector-push-vector ((obj gl-buffer-vector) value-vec)
  (with-slots (gl-buffer size capacity) obj
    (when (> (+ size (length value-vec)) capacity)
          (gl-buffer-vector-reserve obj (max (* 2 capacity) (+ size (length value-vec)))))
    
    (gl:bind-buffer :array-buffer gl-buffer)
    (let ((gl-array (gl:map-buffer-to-gl-array :array-buffer :write-only :float)))
      (dotimes (i (length value-vec))
        (setf (gl:glaref gl-array size) (aref value-vec i))
        (incf size))
      (gl:unmap-buffer :array-buffer))
    (gl:bind-buffer :array-buffer 0)
    
    ;(let ((gl-array (gl:alloc-gl-array :float (length value-vec))))
    ;  (dotimes (i (length value-vec))
    ;    (setf (gl:glaref gl-array i) (aref value-vec i)))
    ;  (gl:bind-buffer :array-buffer gl-buffer)
    ;  (gl:buffer-sub-data :array-buffer gl-array :buffer-offset (* size (cffi:foreign-type-size :float)))
    ;  (gl:free-gl-array gl-array)
    ;  (gl:bind-buffer :array-buffer 0))
    ;(incf size (length value-vec))
    ))

(let ((test 2))
          (case test
            (0 (with-slots (model-matrix-array) obj
                 (let ((gl-array (gl:alloc-gl-array :float (array-total-size model-matrix-array)))
                       (lisp-array (make-array (fill-pointer model-matrix-array) :element-type 'cffi::float :initial-element (cffi::float 0))))
                   (dotimes (i (fill-pointer model-matrix-array))
                     (setf (aref lisp-array i) (aref model-matrix-array i)))
                   (cffi:lisp-array-to-foreign lisp-array (gl::gl-array-pointer gl-array) :float)
                   (gl:buffer-data :array-buffer :dynamic-draw gl-array)
                   (gl:free-gl-array gl-array))))
            (1 (let* ((lisp-vector (texture-model-matrix-array obj))
                      (element-count (fill-pointer lisp-vector))
                      (lisp-array (make-array element-count :element-type 'single-float)))
                 (dotimes (i element-count)
                   (setf (aref lisp-array i) (aref lisp-vector i)))
                 (let* ((array-ptr (cffi:foreign-array-alloc lisp-array :float))
                        (gl-array (gl::make-gl-array-from-pointer array-ptr :float element-count)))
                   (gl:buffer-data :array-buffer :dynamic-draw gl-array)
                   (cffi:foreign-array-free array-ptr))))
            (2 (let* ((lisp-vector (texture-model-matrix-array obj))
                      (element-count (fill-pointer lisp-vector))
                      (lisp-array (make-array element-count :element-type 'single-float)))
                 ; TODO: remove unnecessary copy
                 (dotimes (i element-count)
                   (setf (aref lisp-array i) (aref lisp-vector i)))
                 (waaf-cffi:with-array-as-foreign-pointer (lisp-array ptr :float
                                                                          :lisp-type single-float
                                                                          :start 0
                                                                          :end element-count
                                                                          :copy-to-foreign T
                                                                          :copy-from-foreign NIL)
                   (gl:buffer-data :array-buffer :dynamic-draw (gl::make-gl-array-from-pointer ptr :float element-count)))))))